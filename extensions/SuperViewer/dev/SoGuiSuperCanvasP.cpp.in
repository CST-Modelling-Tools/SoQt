/**************************************************************************
 *
 *  This file is part of the Coin SoQt GUI binding library.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version
 *  2.1 as published by the Free Software Foundation.  See the file
 *  LICENSE.LGPL at the root directory of the distribution for all the
 *  details.
 *
 *  If you want to use Coin SoQt for applications not compatible with the
 *  LGPL, please contact SIM to acquire a Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

#include "So@Gui@SuperCanvasP.h"
#include "So@Gui@SuperCanvas.h"

#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/nodes/SoOrthographicCamera.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/nodes/SoMaterialBinding.h>
#include <Inventor/nodes/SoIndexedLineSet.h>
#include <Inventor/nodes/SoCone.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoCylinder.h>
#include <Inventor/nodes/SoSphere.h>
#include <Inventor/nodes/SoDirectionalLight.h>
#include <Inventor/nodes/SoPolygonOffset.h>
#include <Inventor/nodekits/SoBaseKit.h>
#include <Inventor/actions/SoSearchAction.h>
#include <Inventor/actions/SoGetBoundingBoxAction.h>
#include <Inventor/actions/SoGetPrimitiveCountAction.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoLocation2Event.h>
#include <Inventor/sensors/SoFieldSensor.h>
#include <Inventor/sensors/SoTimerSensor.h>
#include <Inventor/projectors/SbSphereSheetProjector.h>
#include <Inventor/errors/SoDebugError.h>

#include <Inventor/@Gui@/So@Gui@Cursor.h>

static const int MOUSEPOSLOGSIZE = 16;

So@Gui@SuperCanvasP::So@Gui@SuperCanvasP(So@Gui@SuperCanvas * o)
: owner(o) 
{
  this->filled = TRUE;
  this->boundingboxesenabled = FALSE;
  this->wireframeenabled = FALSE;
  this->verticesenabled = FALSE;
  this->hiddenpartsenabled = FALSE;
  this->texturesenabled = FALSE;
  this->informationenabled = FALSE;
  this->notmovingfull = FALSE;
  this->mouseenabled = TRUE;

  this->distanceenabled = FALSE;
  this->flatshadingenabled = FALSE;
  this->spinanimatingallowed = TRUE;
  this->spinanimating = FALSE;
  this->flying = FALSE;
  this->frontcamera = FALSE;

  this->viewmode = So@Gui@SuperCanvas::EXAMINE;
  this->howtomove = So@Gui@SuperCanvas::FULL_MODEL_WM;
  this->drawstyles = 0;
  this->drawstyledirty = 0;
  this->movingdirty = FALSE;
  this->polygonoffsetindex = -1;
  this->complexityindex = -1;
  this->texturequality = 1.0;
  this->antialiasvalue = 5;

  this->canvas = NULL;
  this->viewerwidget = NULL;

  this->currentroot = NULL;
  this->supersg = NULL;
  this->cameraswitch = NULL;
  this->drawstyleroot = NULL;
  this->hiddenlineroot = NULL;
  this->bboxroot = NULL;
  this->polygonoffsetparent = NULL;
  this->graphswitch = NULL;
  this->lightmodel = NULL;
  this->basecolor = NULL;

  this->polygonoffset = NULL;
  this->materialbinding = NULL;
  this->bbox = NULL;
  this->bboxvertices = NULL;
  this->countaction = NULL;
  this->bboxaction = NULL;
  this->cones = 0;
  this->cubes = 0;
  this->cylinders = 0;
  this->spheres = 0;

  this->searchaction = NULL;
  this->shapehints = NULL;
  this->emptynormal = NULL;
  this->emptynormalbinding = NULL;
  this->drawstyle = NULL;
  this->complexity = NULL;

  this->linecolor = SbColor(1.0, 0.0, 0.0);
  this->pointcolor = SbColor(0.0, 1.0, 1.0);

  this->prevRedrawTime = SbTime::getTimeOfDay();
  this->spinRotation.setValue(SbVec3f(0, 0, -1), 0);
  this->spinprojector = new SbSphereSheetProjector;
  SbViewVolume volume;
  volume.ortho(-1, 1, -1, 1, -1, 1);
  this->spinprojector->setViewVolume(volume);
  this->spinsamplecounter = 0;
  this->spinincrement = SbRotation::identity();
  this->log.size = MOUSEPOSLOGSIZE;
  this->log.position = new SbVec2s [ MOUSEPOSLOGSIZE ];
  this->log.time = new SbTime [ MOUSEPOSLOGSIZE ];
  this->log.historysize = 0;
  this->button1down = FALSE;
  this->button2down = FALSE;
  this->button3down = FALSE;
  this->controldown = FALSE;
  this->motion3oncamera = FALSE;

  this->shouldscheduleredraw = FALSE;
  this->flying = FALSE;
  this->pause = FALSE;
  this->busy = FALSE;
  this->flymode = So@Gui@SuperCanvasP::FLYMODE;
  this->timersensor = 
    new SoTimerSensor(So@Gui@SuperCanvasP::timercb, this);
  this->relspeedglide = 0.1f;
  this->relspeedfly = 0.0f;
  this->glidespeed = 30.0f;
  this->flyspeed = 100.0f;
  this->doresetroll = TRUE;
  this->viewupaxis = SbVec3f(0.0f, 0.0f, 1.0f);
  this->camerapossensor = 
    new SoFieldSensor(So@Gui@SuperCanvasP::camera_pos_cb, this);
  this->camerapossensor->setPriority(0);
  this->cameraorientsensor = 
    new SoFieldSensor(So@Gui@SuperCanvasP::camera_orient_cb, this);
  this->cameraorientsensor->setPriority(0);
  this->currcam = NULL;

  owner->setBackgroundColor(SbColor(0.0, 0.0, 0.4));

}

So@Gui@SuperCanvasP::~So@Gui@SuperCanvasP(void)
{
  
}

// *************************************************************************

/*!
  \internal

  Return the parent node in the scene graph of the given \a node.
  NB: this is just a quick'n'dirty thing for often executed code,
  and doesn't cover cases where nodes have multiple parents.
*/

SoGroup *
So@Gui@SuperCanvasP::getParentOfNode(SoNode * root, SoNode * node, int & index)
{
  SbBool oldsearch = SoBaseKit::isSearchingChildren();
  SoBaseKit::setSearchingChildren(TRUE);

  assert(node && root && "get_parent_of_node() called with null argument");

  this->searchaction = new SoSearchAction;
  this->searchaction->reset();
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setNode(node);
  this->searchaction->apply(root);
  if(!this->searchaction->getPath()) return NULL;
  SoNode * parent =
    ((SoFullPath *) this->searchaction->getPath())->getNodeFromTail(1);
  assert(parent && "couldn't find parent");
  delete this->searchaction;
  this->searchaction = NULL;
  SoBaseKit::setSearchingChildren(oldsearch);
  index = ((SoGroup *)parent)->findChild(node);
  return (SoGroup *)parent;

}

void
So@Gui@SuperCanvasP::movingRedraw(SbBool on)
{
  if(on){
    this->movingdirty = TRUE;
    mt = this->texturesenabled;
    mf = this->filled;
    mv = this->verticesenabled;
    mw = this->wireframeenabled;
    mb = this->boundingboxesenabled;
    if(howtomove == So@Gui@SuperCanvas::ONE_BOUNDINGBOX_WM){
      this->graphswitch->whichChild = 1;
    }
    else{
      owner->setDrawStyle(So@Gui@SuperCanvas::TEXTURES, FALSE);
      owner->setDrawStyle(So@Gui@SuperCanvas::VERTICES, FALSE);
      owner->setDrawStyle(So@Gui@SuperCanvas::WIREFRAME, FALSE);
      if(howtomove == So@Gui@SuperCanvas::BOUNDINGBOXES_WM){
        owner->setDrawStyle(So@Gui@SuperCanvas::FILLED, FALSE);
        owner->setDrawStyle(So@Gui@SuperCanvas::BOUNDINGBOXES, TRUE);
      }
      else
        owner->setDrawStyle(So@Gui@SuperCanvas::BOUNDINGBOXES, FALSE);
    }
  }
  else{
    this->movingdirty = FALSE;
    owner->setDrawStyle(So@Gui@SuperCanvas::FILLED, mf);
    owner->setDrawStyle(So@Gui@SuperCanvas::TEXTURES, mt);
    owner->setDrawStyle(So@Gui@SuperCanvas::VERTICES, mv);
    owner->setDrawStyle(So@Gui@SuperCanvas::WIREFRAME, mw);
    owner->setDrawStyle(So@Gui@SuperCanvas::BOUNDINGBOXES, mb);
    if(this->graphswitch->whichChild.getValue() != 0) 
      this->graphswitch->whichChild = 0;
  } 
} // movingRedraw()


void
So@Gui@SuperCanvasP::setupNodes()
{
  if(this->searchaction == NULL)
    this->searchaction = new SoSearchAction;
  this->searchaction->reset(); 
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setInterest(SoSearchAction::FIRST);
  this->supersg = (SoSeparator *)owner->getSceneManager()->getSceneGraph();
  //SoSeparator * usersg = NULL;

#define LOCATE_NODE(member, type, name) \
  do { \
    member = NULL; \
    this->searchaction->setName(SbName(name)); \
    this->searchaction->apply(this->supersg); \
    if (this->searchaction->isFound()) { \
      SoNode * node = this->searchaction->getPath()->getTail(); \
      assert(node != NULL); \
      if (node->isOfType(type::getClassTypeId())) \
        member = (type *) node; \
    } else { \
      SoDebugError::post("So@gui@SuperCanvasP::setupNodes", \
                         "didn't locate node \"%s\"", name); \
    } \
  } while (FALSE)

  LOCATE_NODE(this->drawstyleroot, SoSwitch, "so@gui@->drawstyleroot");
  LOCATE_NODE(this->hiddenlineroot, SoSwitch, "so@gui@->hiddenlineroot");
  LOCATE_NODE(this->polygonoffsetparent, SoSwitch, "so@gui@->polygonoffsetparent");
  
  LOCATE_NODE(this->basecolor, SoBaseColor, "so@gui@->basecolor");
  LOCATE_NODE(this->complexity, SoComplexity, "so@gui@->complexity");
  LOCATE_NODE(this->drawstyle, SoDrawStyle, "so@gui@->drawstyle");
  LOCATE_NODE(this->lightmodel, SoLightModel, "so@gui@->lightmodel");
  LOCATE_NODE(this->materialbinding, SoMaterialBinding, "so@gui@->materialbinding");
  //LOCATE_NODE(usersg, SoSeparator, "soqt->userscenegraphroot");
#ifdef HAVE_SOPOLYGONOFFSET
  LOCATE_NODE(this->polygonoffset, SoPolygonOffset, "so@gui@->polygonoffset");
  if(this->polygonoffset) this->polygonoffset->setOverride(TRUE);
#endif

#undef LOCATE_NODE
      
  this->materialbinding->value.setIgnored(FALSE); // override with OVERALL
  this->polygonoffsetparent->whichChild = SO_SWITCH_ALL;
  this->polygonoffsetindex = this->hiddenlineroot->findChild(this->polygonoffsetparent);
  this->complexityindex = this->drawstyleroot->findChild(this->complexity);
  this->lightmodelindex = this->drawstyleroot->findChild(this->lightmodel);
  this->hiddenlineroot->whichChild = this->polygonoffsetindex;
  this->basecolor->rgb.setIgnored(TRUE);
  this->complexity->value = 1.0;
  this->complexity->textureQuality = 1.0;
  this->bbox = new SoIndexedLineSet;
  this->bboxvertices = new SoVertexProperty;
  this->bboxvertices->vertex.setNum(8);
  this->bbox->vertexProperty = this->bboxvertices;
  this->bboxroot = new SoSwitch;
  this->bboxroot->addChild(new SoPerspectiveCamera);
  this->bboxroot->addChild(this->bbox);
  this->graphswitch->addChild(this->bboxroot);
  this->graphswitch->whichChild = 0;
  this->drawstyle->lineWidth.setIgnored(FALSE);
  this->drawstyle->pointSize.setIgnored(FALSE);
  this->drawstyle->pointSize = 2.0f;
  this->drawstyle->style = SoDrawStyle::INVISIBLE;
  this->drawstyleroot->whichChild = this->complexityindex;
  this->hiddenlineroot->whichChild = this->polygonoffsetindex;
  delete this->searchaction;
  this->searchaction = NULL;

} // setupNodes()

//static stash
// FIXME: Most of the static code below is redundant since it also
// exists in SoGuiViewer. larsivi 20020305

static unsigned char fps2dfont[][12] = {
  {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, //
  {  0,  0, 12, 12,  0,  8, 12, 12, 12, 12, 12,  0 }, // !
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 20, 20 }, // \"
  {  0,  0, 18, 18, 18, 63, 18, 18, 63, 18, 18,  0 }, // #
  {  0,  8, 28, 42, 10, 10, 12, 24, 40, 42, 28,  8 }, // $
  {  0,  0,  6, 73, 41, 22,  8, 52, 74, 73, 48,  0 }, // %
  {  0, 12, 18, 18, 12, 25, 37, 34, 34, 29,  0,  0 }, // &
  { 12, 12, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // '
  {  0,  6,  8,  8, 16, 16, 16, 16, 16,  8,  8,  6 }, // (
  {  0, 48,  8,  8,  4,  4,  4,  4,  4,  8,  8, 48 }, //)
  {  0,  0,  0,  0,  0,  0,  8, 42, 20, 42,  8,  0 }, // *
  {  0,  0,  0,  8,  8,  8,127,  8,  8,  8,  0,  0 }, // +
  {  0, 24, 12, 12,  0,  0,  0,  0,  0,  0,  0,  0 }, // ,
  {  0,  0,  0,  0,  0,  0,127,  0,  0,  0,  0,  0 }, // -
  {  0,  0, 24, 24,  0,  0,  0,  0,  0,  0,  0,  0 }, // .
  {  0, 32, 32, 16, 16,  8,  8,  8,  4,  4,  2,  2 }, // /
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 28,  0 }, // 0
  {  0,  0,  8,  8,  8,  8,  8,  8, 40, 24,  8,  0 }, // 1
  {  0,  0, 62, 32, 16,  8,  4,  2,  2, 34, 28,  0 }, // 2
  {  0,  0, 28, 34,  2,  2, 12,  2,  2, 34, 28,  0 }, // 3
  {  0,  0,  4,  4,  4,126, 68, 36, 20, 12,  4,  0 }, // 4
  {  0,  0, 28, 34,  2,  2,  2, 60, 32, 32, 62,  0 }, // 5
  {  0,  0, 28, 34, 34, 34, 60, 32, 32, 34, 28,  0 }, // 6
  {  0,  0, 16, 16, 16,  8,  8,  4,  2,  2, 62,  0 }, // 7
  {  0,  0, 28, 34, 34, 34, 28, 34, 34, 34, 28,  0 }, // 8
  {  0,  0, 28, 34,  2,  2, 30, 34, 34, 34, 28,  0 }, // 9
  {  0,  0, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // :
  {  0, 48, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // ;
  {  0,  0,  0,  2,  4,  8, 16,  8,  4,  2,  0,  0 }, // <
  {  0,  0,  0,  0,  0,127,  0,127,  0,  0,  0,  0 }, // =
  {  0,  0,  0, 16,  8,  4,  2,  4,  8, 16,  0,  0 }, // >
  {  0,  0, 16, 16,  0, 16, 28,  2,  2,  2, 60,  0 }, // ?
  {  0,  0, 28, 32, 73, 86, 82, 82, 78, 34, 28,  0 }, // @
  {  0,  0, 33, 33, 33, 63, 18, 18, 18, 12, 12,  0 }, // A
  {  0,  0, 60, 34, 34, 34, 60, 34, 34, 34, 60,  0 }, // B
  {  0,  0, 14, 16, 32, 32, 32, 32, 32, 18, 14,  0 }, // C
  {  0,  0, 56, 36, 34, 34, 34, 34, 34, 36, 56,  0 }, // D
  {  0,  0, 62, 32, 32, 32, 60, 32, 32, 32, 62,  0 }, // E
  {  0,  0, 16, 16, 16, 16, 30, 16, 16, 16, 30,  0 }, // F
  {  0,  0, 14, 18, 34, 34, 32, 32, 32, 18, 14,  0 }, // G
  {  0,  0, 34, 34, 34, 34, 62, 34, 34, 34, 34,  0 }, // H
  {  0,  0, 62,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // I
  {  0,  0,112,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // J
  {  0,  0, 33, 33, 34, 36, 56, 40, 36, 34, 33,  0 }, // K
  {  0,  0, 30, 16, 16, 16, 16, 16, 16, 16, 16,  0 }, // L
  {  0,  0, 33, 33, 33, 45, 45, 45, 51, 51, 33,  0 }, // M
  {  0,  0, 34, 34, 38, 38, 42, 42, 50, 50, 34,  0 }, // N
  {  0,  0, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // O
  {  0,  0, 32, 32, 32, 60, 34, 34, 34, 34, 60,  0 }, // P
  {  3,  6, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // Q
  {  0,  0, 34, 34, 34, 36, 60, 34, 34, 34, 60,  0 }, // R
  {  0,  0, 60,  2,  2,  6, 28, 48, 32, 32, 30,  0 }, // S
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,127,  0 }, // T
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 34,  0 }, // U
  {  0,  0, 12, 12, 18, 18, 18, 33, 33, 33, 33,  0 }, // V
  {  0,  0, 34, 34, 34, 54, 85, 73, 73, 73, 65,  0 }, // W
  {  0,  0, 34, 34, 20, 20,  8, 20, 20, 34, 34,  0 }, // X
  {  0,  0,  8,  8,  8,  8, 20, 20, 34, 34, 34,  0 }, // Y
  {  0,  0, 62, 32, 16, 16,  8,  4,  4,  2, 62,  0 }, // Z
  {  0, 14,  8,  8,  8,  8,  8,  8,  8,  8,  8, 14 }, // [
  {  0,  2,  2,  4,  4,  8,  8,  8, 16, 16, 32, 32 }, // [backslash]
  {  0, 56,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // ]
  {  0,  0,  0,  0,  0, 34, 34, 20, 20,  8,  8,  0 }, // ^
  {  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // _
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 24, 12 }, // `
  {  0,  0, 29, 34, 34, 30,  2, 34, 28,  0,  0,  0 }, // a
  {  0,  0, 60, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // b
  {  0,  0, 14, 16, 32, 32, 32, 16, 14,  0,  0,  0 }, // c
  {  0,  0, 26, 38, 34, 34, 34, 34, 30,  2,  2,  2 }, // d
  {  0,  0, 28, 34, 32, 62, 34, 34, 28,  0,  0,  0 }, // e
  {  0,  0, 16, 16, 16, 16, 16, 16, 62, 16, 16, 14 }, // f
  { 28,  2,  2, 26, 38, 34, 34, 34, 30,  0,  0,  0 }, // g
  {  0,  0, 34, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // h
  {  0,  0,  8,  8,  8,  8,  8,  8, 56,  0,  8,  8 }, // i
  { 56,  4,  4,  4,  4,  4,  4,  4, 60,  0,  4,  4 }, // j
  {  0,  0, 33, 34, 36, 56, 40, 36, 34, 32, 32, 32 }, // k
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // l
  {  0,  0, 73, 73, 73, 73, 73,109, 82,  0,  0,  0 }, // m
  {  0,  0, 34, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // n
  {  0,  0, 28, 34, 34, 34, 34, 34, 28,  0,  0,  0 }, // o
  { 32, 32, 60, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // p
  {  2,  2, 26, 38, 34, 34, 34, 34, 30,  0,  0,  0 }, // q
  {  0,  0, 16, 16, 16, 16, 16, 24, 22,  0,  0,  0 }, // r
  {  0,  0, 60,  2,  2, 28, 32, 32, 30,  0,  0,  0 }, // s
  {  0,  0, 14, 16, 16, 16, 16, 16, 62, 16, 16,  0 }, // t
  {  0,  0, 26, 38, 34, 34, 34, 34, 34,  0,  0,  0 }, // u
  {  0,  0,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // v
  {  0,  0, 34, 34, 34, 85, 73, 73, 65,  0,  0,  0 }, // w
  {  0,  0, 34, 34, 20,  8, 20, 34, 34,  0,  0,  0 }, // x
  { 48, 16,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // y
  {  0,  0, 62, 32, 16,  8,  4,  2, 62,  0,  0,  0 }, // z
  {  0,  6,  8,  8,  8,  4, 24,  4,  8,  8,  8,  6 }, // {
  {  0,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8 }, // |
  {  0, 48,  8,  8,  8, 16, 12, 16,  8,  8,  8, 48 }, // }
  {  0,  0,  0,  0,  0,  0, 78, 57,  0,  0,  0,  0 }  // ~
};

static int indices[36] = {
  0, 1, SO_END_LINE_INDEX,
  1, 2, SO_END_LINE_INDEX,
  2, 3, SO_END_LINE_INDEX,
  3, 0, SO_END_LINE_INDEX,
  0, 4, SO_END_LINE_INDEX,
  4, 5, SO_END_LINE_INDEX,
  5, 1, SO_END_LINE_INDEX,
  5, 6, SO_END_LINE_INDEX,
  6, 2, SO_END_LINE_INDEX,
  6, 7, SO_END_LINE_INDEX,
  7, 3, SO_END_LINE_INDEX,
  7, 4, SO_END_LINE_INDEX
};

static void
printString(const char * s)
{
#if defined(__COIN__)
  int i,n;
  n = strlen(s);
  for (i = 0; i < n; i++)
    glBitmap(8, 12, 0.0, 2.0, 10.0, 0.0, fps2dfont[s[i] - 32]);
#endif
} // printString()

static void
Draw2DString(const char * str, SbVec2s glsize, SbVec2f position)
{
  // Store GL state.
  glPushAttrib(GL_ALL_ATTRIB_BITS);

  glDisable(GL_LIGHTING);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_TEXTURE_2D);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();

  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0.0, glsize[0], 0.0, glsize[1], -1, 1);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glColor3f(0.0, 0.0, 0.0);
  glRasterPos2f(position[0] + 1, position[1]);
  printString(str);
  glRasterPos2f(position[0] - 1, position[1]);
  printString(str);
  glRasterPos2f(position[0], position[1] + 1);
  printString(str);
  glRasterPos2f(position[0], position[1] - 1);
  printString(str);

  glColor3f(1.0, 1.0, 1.0);
  glRasterPos2f(position[0], position[1]);
  printString(str);

  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();

  glPopAttrib();
} // Draw2DString()

void
So@Gui@SuperCanvasP::drawInformation()
{
  if(this->countaction == NULL) this->resetCountAction();
  short vertmove = 0;

  char buffer[64];
  if(this->spheres){
    int nr = sprintf(buffer, "Spheres: %d", this->spheres);
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
    vertmove += 20;
  }
  if(this->cylinders){
    int nr = sprintf(buffer, "Cylinders: %d", this->cylinders);
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
    vertmove += 20;
  }
  if(this->cubes){
    int nr = sprintf(buffer, "Cubes: %d", this->cubes);
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
    vertmove += 20;
  }
  if(this->cones){
    int nr = sprintf(buffer, "Cones: %d", this->cones);
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
    vertmove += 20;
  }
  if(this->countaction->getTriangleCount()){
    int nr = sprintf(buffer, "Triangles: %d", 
                     this->countaction->getTriangleCount());
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
    vertmove += 20;
  }
  if(this->distanceenabled){
    SoCamera * cam = owner->getCamera();
    if (cam == NULL) return; // can happen for empty scenegraph

    SbVec3f campos = cam->position.getValue();

    this->bboxaction = new SoGetBoundingBoxAction(owner->getViewportRegion());
    this->bboxaction->apply(this->currentroot);
    SbBox3f bboxvec = this->bboxaction->getBoundingBox();
    SbVec3f center = bboxvec.getCenter();
    delete this->bboxaction;
    this->bboxaction = NULL;

    campos.operator-=(center);
    float distance = campos.length();
    int nt = sprintf(buffer, "Distance: %f", distance);
    Draw2DString(buffer, owner->getGLSize(), SbVec2f(20, 40 + vertmove));
  }
} // drawInformation()


void
So@Gui@SuperCanvasP::resetCountAction()
{
  if(this->countaction != NULL){
    delete this->countaction;
    this->countaction = NULL;
  }
  
  this->cones = this->cubes = this->cylinders = this->spheres = 0;
  countaction = new SoGetPrimitiveCountAction;
 
  if(this->currentroot != NULL){
    this->countaction->apply(this->currentroot); 

    this->searchaction = new SoSearchAction;
    this->searchaction->setInterest(SoSearchAction::ALL);
    this->searchaction->setType(SoCone::getClassTypeId(), TRUE);
    this->searchaction->apply(currentroot);
    this->cones = searchaction->getPaths().getLength();
    this->searchaction->reset();
    this->searchaction->setInterest(SoSearchAction::ALL);
    this->searchaction->setType(SoCube::getClassTypeId(), TRUE);
    this->searchaction->apply(this->currentroot);
    this->cubes = this->searchaction->getPaths().getLength();
    this->searchaction->reset();
    this->searchaction->setInterest(SoSearchAction::ALL);
    this->searchaction->setType(SoCylinder::getClassTypeId(), TRUE);
    this->searchaction->apply(this->currentroot);
    this->cylinders = this->searchaction->getPaths().getLength();
    this->searchaction->reset();
    this->searchaction->setInterest(SoSearchAction::ALL);
    this->searchaction->setType(SoSphere::getClassTypeId(), TRUE);
    this->searchaction->apply(this->currentroot);
    this->spheres = this->searchaction->getPaths().getLength();
    delete this->searchaction;
    this->searchaction = NULL;
  }
} // resetCountAction()

void
So@Gui@SuperCanvasP::resetBBox()
{
  this->bboxaction = new SoGetBoundingBoxAction(owner->getViewportRegion());
  this->bboxaction->apply(this->currentroot);
  SbBox3f bboxvec = this->bboxaction->getBoundingBox();
  float minx, miny, minz, maxx, maxy, maxz;
  minx = miny = minz =  maxx = maxy = maxz = 0.0;
  bboxvec.getBounds(minx, miny, minz, maxx, maxy, maxz);
  this->bboxvertices->vertex.set1Value(0, minx, miny, minz);
  this->bboxvertices->vertex.set1Value(1, minx, miny, maxz);
  this->bboxvertices->vertex.set1Value(2, maxx, miny, maxz);
  this->bboxvertices->vertex.set1Value(3, maxx, miny, minz);
  this->bboxvertices->vertex.set1Value(4, minx, maxy, minz);
  this->bboxvertices->vertex.set1Value(5, minx, maxy, maxz);
  this->bboxvertices->vertex.set1Value(6, maxx, maxy, maxz);
  this->bboxvertices->vertex.set1Value(7, maxx, maxy, minz);
  this->bbox->coordIndex.setValues(0, 36, indices);

  delete this->bboxaction;
  this->bboxaction = NULL;
}

void
So@Gui@SuperCanvasP::setBBoxCameraType()
{
  SbBool persp = TRUE;
  SoType t = owner->getCameraType();

  SoCamera * newcamera = (SoCamera *)t.createInstance();
  SoCamera * viewcam = owner->getCamera();
  this->bboxroot->replaceChild(0, newcamera);

  newcamera->viewportMapping.connectFrom(&viewcam->viewportMapping);
  newcamera->position.connectFrom(&viewcam->position);
  newcamera->orientation.connectFrom(&viewcam->orientation);
  newcamera->aspectRatio.connectFrom(&viewcam->aspectRatio);
  newcamera->nearDistance.connectFrom(&viewcam->nearDistance);
  newcamera->farDistance.connectFrom(&viewcam->farDistance);
  newcamera->focalDistance.connectFrom(&viewcam->focalDistance);

}

void
So@Gui@SuperCanvasP::drawstyleRedraw(SbBool on)
{
  if(on){
    this->drawstyleroot->whichChild = SO_SWITCH_ALL;
    this->hiddenlineroot->whichChild = SO_SWITCH_ALL;
    this->lightmodel->model.setIgnored(FALSE);
    this->materialbinding->value.setIgnored(FALSE); // override with OVERALL
    if(!this->filled && this->hiddenpartsenabled){
      this->drawstyledirty += 2;
      // render as filled, but with the background color.
      this->drawstyle->style.setIgnored(TRUE); // draw as-is filled/lines/points
      this->complexity->type.setIgnored(TRUE); // as-is rendering space
      this->complexity->value.setIgnored(TRUE); // as-is complexity on non-simple shapes 
      this->basecolor->rgb.setIgnored(FALSE);
      this->basecolor->rgb.setValue(owner->getBackgroundColor());
      owner->getSceneManager()->render(FALSE,FALSE);
    }
    if(this->boundingboxesenabled){
      if(this->drawstyledirty)
        this->drawstyleRedraw(FALSE);
      this->drawstyledirty += 4;
      this->complexity->type = SoComplexity::BOUNDING_BOX;
      this->drawstyle->style = SoDrawStyle::LINES;
      owner->getSceneManager()->render(FALSE,FALSE);
    }
    if(this->wireframeenabled){
      if(this->drawstyledirty)
        this->drawstyleRedraw(FALSE);
      this->drawstyledirty += 8;
      if(this->filled){
        this->drawstyledirty += 32;
        this->basecolor->rgb.setIgnored(FALSE);
        this->basecolor->rgb.setValue(this->linecolor);
      }
      this->drawstyle->style = SoDrawStyle::LINES;
      this->polygonoffsetparent->whichChild = SO_SWITCH_NONE;
      owner->getSceneManager()->render(FALSE,FALSE);
    } 

    if(this->verticesenabled){
      if(this->drawstyledirty)
        this->drawstyleRedraw(FALSE);
      this->drawstyledirty += 16;
      if(this->filled){
        this->drawstyledirty += 32;
        this->basecolor->rgb.setIgnored(FALSE);
        this->basecolor->rgb.setValue(this->pointcolor);
      }
      this->drawstyle->style = SoDrawStyle::POINTS;
      owner->getSceneManager()->render(FALSE,FALSE);
    }
    this->drawstyledirty += 1;
  }
  else{
    if(this->drawstyledirty & 2){
      this->drawstyledirty -= 2;
      this->hiddenlineroot->whichChild = this->polygonoffsetindex;
      this->basecolor->rgb.setIgnored(TRUE);
      this->drawstyle->style.setIgnored(FALSE); 
      this->complexity->type.setIgnored(FALSE); 
      this->complexity->value.setIgnored(FALSE);
    }
    if(this->drawstyledirty & 4){
      this->drawstyledirty -= 4;
      this->complexity->type = SoComplexity::OBJECT_SPACE;
      this->drawstyle->style = SoDrawStyle::INVISIBLE;
    }
    if(this->drawstyledirty & 8){
      this->drawstyledirty -= 8;
      this->polygonoffsetparent->whichChild = SO_SWITCH_ALL;
      //this->drawstyle->style.setIgnored(TRUE);  
      this->drawstyle->style = SoDrawStyle::INVISIBLE;
    }
    if(this->drawstyledirty & 16){
      this->drawstyledirty -= 16;
      this->drawstyle->style = SoDrawStyle::INVISIBLE;
    }
    if(this->drawstyledirty & 32){
      this->drawstyledirty -= 32;
      this->basecolor->rgb.setIgnored(TRUE);
    }
    if(this->drawstyledirty & 1){
      this->lightmodel->model.setIgnored(TRUE);
      this->hiddenlineroot->whichChild = this->polygonoffsetindex;
      this->drawstyleroot->whichChild = this->filled ? SO_SWITCH_NONE :
                                                       SO_SWITCH_ALL;
      this->drawstyle->style = SoDrawStyle::INVISIBLE;
      this->drawstyledirty = 0;
      this->materialbinding->value.setIgnored(TRUE); 
    }
  }
} // drawstyleRedraw()

// *************************************************************************
// Methods used for spin animation tracking.

/*!
  This method "clears" the mouse location log, used for spin animation
  calculations.
*/

void
So@Gui@SuperCanvasP::clearLog(
  void)
{
  this->log.historysize = 0;
} // clearLog()

/*!
  This method adds another point to the mouse location log, used for spin
  animation calculations.
*/

void
So@Gui@SuperCanvasP::addToLog(
  const SbVec2s pos,
  const SbTime time)
{
  // In case someone changes the const size setting at the top of this
  // file too small.
  assert (this->log.size > 2 && "mouse log too small!");

  if (this->log.historysize > 0 && pos == this->log.position[0]) {
#if SOQT_DEBUG && 0 // debug
    // This can at least happen under SoQt.
    SoDebugError::postInfo("SoQtSuperViewer::addToLog", "got position already!");
#endif // debug
    return;
  }

  for (int i = this->log.size - 1; i > 0; i--) {
    this->log.position[i] = this->log.position[i-1];
    this->log.time[i] = this->log.time[i-1];
  }
  this->log.position[0] = pos;
  this->log.time[0] = time;
  if (this->log.historysize < this->log.size)
    this->log.historysize += 1;
} // addToLog()

// ************************************************************************

/*!
  \internal

  The viewer is a state machine, and all changes to the current state
  are made through this call.
*/

void
So@Gui@SuperCanvasP::setMode(const HelpMode mode)
{
  this->setCursorRepresentation(mode);

  switch (mode) {
  case FLYMODE:
    break;
  case INTERACT:

    break;
  case EXAMINE:
    // FIXME: this looks like someone fixed the symptom instead of
    // fixing the cause? 20010709 mortene.
    while (owner->getInteractiveCount())
      owner->interactiveCountDec();
    break;

  case DRAGGING:
    // Set up initial projection point for the projector object when
    // first starting a drag operation.
    this->spinprojector->project(this->lastmouseposition);
    break;

  case PANNING:
    {
      // The plane we're projecting the mouse coordinates to get 3D
      // coordinates should stay the same during the whole pan
      // operation, so we should calculate this value here.
      SoCamera * cam = owner->getCamera();
      if (cam == NULL) { // can happen for empty scenegraph
        this->panningplane = SbPlane(SbVec3f(0, 0, 1), 0);
      }
      else {
        SbViewVolume vv = cam->getViewVolume(owner->getGLAspectRatio());
        this->panningplane = vv.getPlane(cam->focalDistance.getValue());
      }
    }
    break;

  default: // include default to avoid compiler warnings.
    break;
  }

  this->currentmode = mode;
} // setMode()

// ************************************************************************

/*!
  \internal

  Set cursor graphics according to mode.
*/

void
So@Gui@SuperCanvasP::setCursorRepresentation(int mode)
{
  // FIXME: with the new So@Gui@Cursor class, this has actually become
  // a possibly generic method for all So* toolkits. Move to common
  // code. 20011125 mortene.

  if (!owner->isCursorEnabled()) {
    owner->setComponentCursor(So@Gui@Cursor::getBlankCursor());
    return;
  }

  switch (mode) {
  case So@Gui@SuperCanvasP::FLYMODE:
  case So@Gui@SuperCanvasP::INTERACT:
  case So@Gui@SuperCanvasP::EXAMINE:
    owner->setComponentCursor(So@Gui@Cursor(So@Gui@Cursor::DEFAULT));
    break;
  case So@Gui@SuperCanvasP::DRAGGING:
    owner->setComponentCursor(So@Gui@Cursor::getRotateCursor());
    break;

  case So@Gui@SuperCanvasP::ZOOMING:
    owner->setComponentCursor(So@Gui@Cursor::getZoomCursor());
    break;

  case So@Gui@SuperCanvasP::WAITING_FOR_SEEK:
    owner->setComponentCursor(So@Gui@Cursor(So@Gui@Cursor::CROSSHAIR));
    break;

  case So@Gui@SuperCanvasP::WAITING_FOR_PAN:
  case So@Gui@SuperCanvasP::PANNING:
    owner->setComponentCursor(So@Gui@Cursor::getPanCursor());
    break;

  default: assert(0); break;
  }
} // setCursorRepresentation()

// *************************************************************************

/*!
  \internal

  Rotate the camera by the given amount, then reposition it so we're still
  pointing at the same focal point.
*/

void
So@Gui@SuperCanvasP::reorientCamera(
  const SbRotation & rot)
{
  SoCamera * cam = owner->getCamera();
  if (cam == NULL) return;

  // Find global coordinates of focal point.
  SbVec3f direction;
  cam->orientation.getValue().multVec(SbVec3f(0, 0, -1), direction);
  SbVec3f focalpoint = cam->position.getValue() +
    cam->focalDistance.getValue() * direction;

  // Set new orientation value by accumulating the new rotation.
  cam->orientation = rot * cam->orientation.getValue();

  // Reposition camera so we are still pointing at the same old focal point.
  cam->orientation.getValue().multVec(SbVec3f(0, 0, -1), direction);
  cam->position = focalpoint - cam->focalDistance.getValue() * direction;
} // reorientCamera()

// ************************************************************************

/*!
  \internal

  Uses the sphere sheet projector to map the mouseposition unto
  a 3D point and find a rotation from this and the last calculated point.
*/

void
So@Gui@SuperCanvasP::spin(
  const SbVec2f & pointerpos)
{
  if (this->log.historysize < 2) return;
  assert(this->spinprojector != NULL);

  SbVec2s glsize(owner->getGLSize());
  SbVec2f lastpos;
  lastpos[0] = float(this->log.position[1][0]) / 
               float(SoQtMax((int)(glsize[0]-1), 1));
  lastpos[1] = float(this->log.position[1][1]) / 
               float(SoQtMax((int)(glsize[1]-1), 1));

  this->spinprojector->project(lastpos);
  SbRotation r;
  this->spinprojector->projectAndGetRotation(pointerpos, r);
  r.invert();
  this->reorientCamera(r);

  // Calculate an average angle magnitude value to make the transition
  // to a possible spin animation mode appear smooth.

  SbVec3f dummy_axis, newaxis;
  float acc_angle, newangle;
  this->spinincrement.getValue(dummy_axis, acc_angle);
  acc_angle *= this->spinsamplecounter; // weight
  r.getValue(newaxis, newangle);
  acc_angle += newangle;

  this->spinsamplecounter++;
  acc_angle /= this->spinsamplecounter;
  // FIXME: accumulate and average axis vectors aswell? 19990501 mortene.
  this->spinincrement.setValue(newaxis, acc_angle);

  // Don't carry too much baggage, as that'll give unwanted results
  // when the user quickly trigger (as in "click-drag-release") a spin
  // animation.
  if (this->spinsamplecounter > 3) 
    this->spinsamplecounter = 3;
} // spin()

// ************************************************************************

/*!
  \internal

  Move scene parallel with the plane orthogonal to the camera
  direction vector.
*/

void
So@Gui@SuperCanvasP::pan(
  const SbVec2f & thispos,
  const SbVec2f & prevpos)
{
  SoCamera * cam = owner->getCamera();
  if (cam == NULL) return; // can happen for empty scenegraph
  if (thispos == prevpos) {
    return;
  }

  // Find projection points for the last and current mouse coordinates.
  SbViewVolume vv = cam->getViewVolume(owner->getGLAspectRatio());
  SbLine line;
  vv.projectPointToLine(thispos, line);
  SbVec3f current_planept;
  this->panningplane.intersect(line, current_planept);
  vv.projectPointToLine(prevpos, line);
  SbVec3f old_planept;
  this->panningplane.intersect(line, old_planept);

  // Reposition camera according to the vector difference between the
  // projected points.
  cam->position = cam->position.getValue() - (current_planept - old_planept);
} // pan()

// ************************************************************************

/*!
  \internal

  Dependent on the camera type this will either shrink or expand
  the height of the viewport (orthogonal camera) or move the
  camera closer or further away from the focal point in the scene.
*/

void
So@Gui@SuperCanvasP::zoom(
  const float diffvalue)
{
  SoCamera * cam = owner->getCamera();
  if (cam == NULL) return; // can happen for empty scenegraph
  SoType t = cam->getTypeId();

  // This will be in the range of <0, ->>.
  float multiplicator = exp(diffvalue);

  if (t.isDerivedFrom(SoOrthographicCamera::getClassTypeId())) {
    SoOrthographicCamera * oc = (SoOrthographicCamera *)cam;
    oc->height = oc->height.getValue() * multiplicator;
  } else if (t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId())) {
    float oldfocaldist = cam->focalDistance.getValue();
    cam->focalDistance = oldfocaldist * multiplicator;

    SbVec3f direction;
    cam->orientation.getValue().multVec(SbVec3f(0, 0, -1), direction);
    cam->position = cam->position.getValue() +
      (cam->focalDistance.getValue() - oldfocaldist) * -direction;
  } else {
    assert(0 && "impossible");
  }
} // zoom()

// *************************************************************************

/*!
  \internal

  Calculate a zoom/dolly factor from the difference of the current
  cursor position and the last.
*/

void
So@Gui@SuperCanvasP::zoomByCursor(
  const SbVec2f & thispos,
  const SbVec2f & prevpos)
{
  // There is no "geometrically correct" value, 20 just seems to give
  // about the right "feel".
  this->zoom((thispos[1] - prevpos[1]) * 20.0f);
} // zoomByCursor()

// *************************************************************************

#define DIRECTION_NONE 0
#define DIRECTION_FWD  1
#define DIRECTION_BACK 2

/*!
  Internal method that handles mouse events.
*/

SbBool
So@Gui@SuperCanvasP::processFlyEvent(const SoEvent * const event)
{
  SoType eventtype = event->getTypeId();
  
  SbVec2s winsize = owner->getViewportRegion().getWindowSize();
  SbVec2s mousepos = event->getPosition();

  // keep button state in sync
  SbBool leftbuttonevent = FALSE;
  SbBool rightbuttonevent = FALSE;
  SbBool midbuttonevent = FALSE;
  SbBool mousepressevent = FALSE;
  SbBool mousereleaseevent = FALSE;

  if (SO_MOUSE_PRESS_EVENT(event, BUTTON1)) {
    leftbuttonevent = TRUE;
    mousepressevent = TRUE;
    this->button1down = TRUE;
  }
  else if (SO_MOUSE_RELEASE_EVENT(event, BUTTON1)) {
    leftbuttonevent = TRUE;
    mousereleaseevent = TRUE;
    this->button1down = FALSE; 
  }
  else if (SO_MOUSE_PRESS_EVENT(event, BUTTON3)) {
    midbuttonevent = TRUE;
    mousepressevent = TRUE;
    this->button3down = TRUE;
  }
  else if (SO_MOUSE_RELEASE_EVENT(event, BUTTON3)) {
    midbuttonevent = TRUE;
    mousereleaseevent = TRUE;
    this->button3down = FALSE; 
  }
  else if (SO_MOUSE_PRESS_EVENT(event, BUTTON2)) {
    rightbuttonevent = TRUE;
    mousepressevent = TRUE;
    this->button2down = TRUE;
  }
  else if (SO_MOUSE_RELEASE_EVENT(event, BUTTON2)) {
    rightbuttonevent = TRUE;
    mousereleaseevent = TRUE;
    this->button2down = FALSE; 
  }

  if (mousepressevent) {
    this->mousedownpos = mousepos;
    this->flydirection = DIRECTION_NONE;
    this->currentmode = WAITING_FOR_FLY;
    this->prevRedrawTime = SbTime::getTimeOfDay();
    return FALSE;
  }
  else if (mousereleaseevent) {
    this->currentmode = IDLE;
    this->shouldscheduleredraw = TRUE;
    return FALSE;
  }
  else if (eventtype == SoLocation2Event::getClassTypeId()) {
    this->mousepos = mousepos;
    if (this->currentmode == WAITING_FOR_FLY) {
      this->currentmode = this->flymode;
      this->prevRedrawTime = SbTime::getTimeOfDay();
    }
  }
  return FALSE;
} // processFlyEvent()

// *************************************************************************

/*!
  Callback for the animation timer.
*/

void
So@Gui@SuperCanvasP::timercb(void *data, SoSensor *)
{
  ((So@Gui@SuperCanvasP*)data)->pulse();
} // timercb()

// *************************************************************************

/*!
  Sensor callback when camera position changes,
*/

void
So@Gui@SuperCanvasP::camera_pos_cb(void * data, SoSensor * sensor)
{
  static SbTime prevtime = SbTime::zero();
  static SbVec3f prevpos = SbVec3f(0.0, 0.0, -200000.0);

  So@Gui@SuperCanvasP * thisp = (So@Gui@SuperCanvasP*) data;
  SoCamera * camera = (SoCamera*) thisp->owner->getCamera();
 
  SbVec3f pos(0.0, 0.0, 0.0);
  SbVec3f offset(0.0f, 0.0f, 0.0f);

  offset = camera->position.getValue();

  pos[0] += offset[0];
  pos[1] += offset[1];
  pos[2] += offset[2];
  SbVec3f newpos = pos;

  float elev;
  thisp->elevation = -1.0f;

  SbVec3f tmp(offset[0], offset[1], offset[2]);

  if (pos != newpos) {
    thisp->camerapossensor->detach();
 
    camera->position = SbVec3f(offset[0], offset[1], (float) newpos[2]);
    thisp->camerapossensor->attach(&camera->position);
  }

  double dist = (newpos-prevpos).length();
  if (dist < 1000.0) {
    thisp->movedist += (float) dist;
  }
  prevpos = newpos;
} // camera_pos_cb()

// *************************************************************************

/*!
  Sensor callback when camera oreintation changes,
*/

void
So@Gui@SuperCanvasP::camera_orient_cb(void * data, SoSensor *)
{
  So@Gui@SuperCanvasP * thisp = (So@Gui@SuperCanvasP*) data;
  thisp->camerarot.setRotate(thisp->currcam->orientation.getValue());
}  // camera_oritent_cb()

// *************************************************************************

/*!
  Internal method called from the timer callback.
*/

void
So@Gui@SuperCanvasP::pulse(void)
{
  // FIXME: No Joystick support for now.
  // larsivi 20020430

  if (!this->pause && !this->busy) {
    switch (this->viewmode) {
    case So@Gui@SuperCanvas::EXAMINE:
    case So@Gui@SuperCanvas::INTERACT:
      break;
    case So@Gui@SuperCanvas::FLYMODE_NORMAL:
      this->flyPulse();
      break;
    case So@Gui@SuperCanvas::FLYMODE_GLIDE:
      this->glidePulse();
      break;
    case So@Gui@SuperCanvas::FLYMODE_LOCKED:
      this->lockedPulse();
      break;
    default:
      break;
    }
  }
  if (this->shouldscheduleredraw) {
    owner->scheduleRedraw();
    this->shouldscheduleredraw = FALSE;
  }
  this->prevRedrawTime = SbTime::getTimeOfDay();
} // pulse()

// *************************************************************************

/*!
  Pulse while gliding.
*/
void
So@Gui@SuperCanvasP::glidePulse(SbBool joystick)
{
  int dx;
  int dy;
  
  dx = this->mousepos[0] - this->mousedownpos[0];
  dy = - (this->mousepos[1] - this->mousedownpos[1]);
  
  float xmov = float(dx) / 7000.0f;
  float ymov = float(dy) / 6000.0f;
  
  this->yawCamera(-ymov);
  this->pitchCamera(-xmov);
  this->moveCamera(
        SbVec3f(0.0f, 0.0f, -SbAbs(this->relspeedglide*this->glidespeed)), TRUE);
  this->resetRoll();
  this->rollCamera(-xmov*8.0f);
} // glidePulseP()

// *************************************************************************

/*!
  Pulse while flying.
*/

void
So@Gui@SuperCanvasP::flyPulse(SbBool joystick)
{
  SbVec2s winsize = owner->getViewportRegion().getWindowSize();

  int dx;
  int dy;
  // FIXME Joystick support disabled for now.
  // larsivi 20020430
   
  dx = this->mousepos[0] - this->mousedownpos[0];
  dy = - (this->mousepos[1] - this->mousedownpos[1]);
    
  if (this->button1down) {
    if (dy > 0 && this->flydirection == DIRECTION_BACK) {
      dy -= 20;
      if (dy < 0) dy = 0;
    }
    else if (dy < 0 && this->flydirection == DIRECTION_FWD) {
      dy += 20;
      if (dy > 0) dy = 0;
    }
    
    if (dx == 0 && dy == 0) return;
    this->relspeedfly = SbAbs(float(dy))/float(winsize[1]);
    this->moveCamera(SbVec3f(0.0f, 0.0f, (float)dy), TRUE);
    if (this->flydirection == DIRECTION_NONE && dy) {
      if (dy > 0) this->flydirection = DIRECTION_FWD;
      else this->flydirection = DIRECTION_BACK;
    }
    this->pitchCamera(((float)-dx/float(winsize[0])) * 0.1f);
  }
  else if (this->button2down) {
    if (dx == 0 && dy == 0) return;
    this->pitchCamera(((float)-dx / float(winsize[0])) * 0.1f);
    this->yawCamera(((float)-dy / float(winsize[1])) * 0.1f);
  }
  else if (this->button3down) {
    if (dx == 0 && dy == 0) return;
    float fx = float(dx) / float(winsize[0]);
    float fy = float(dy) / float(winsize[1]);
    this->relspeedfly = (float) sqrt(fx*fx+fy*fy);
    this->moveCamera(SbVec3f((float)dx,
                             (float)(-dy),
                             0.0f), TRUE);
  }
} // flyPulse()

// *************************************************************************

void
So@Gui@SuperCanvasP::lockedPulse(SbBool joystick)
{
  SbVec2s winsize = owner->getViewportRegion().getWindowSize();

  int dx = this->mousepos[0] - this->mousedownpos[0];
  int dy = -(this->mousepos[1] - this->mousedownpos[1]);

  if (this->button1down) {
    if (dx == 0 && dy == 0) return;
    if (dy > 0) {
      this->flydirection = DIRECTION_FWD;
    }
    else if (dy < 0) {
      this->flydirection = DIRECTION_BACK;
    }
    float fx = float(dx) / float(winsize[0]);
    float fy = float(dy) / float(winsize[1]);
    this->relspeedfly = (float) sqrt(fx*fx+fy*fy);

    this->moveCamera(SbVec3f((float)dx, 0.0f, (float)dy), TRUE);
    if (this->flydirection == DIRECTION_NONE && dy) {
      if (dy > 0) this->flydirection = DIRECTION_FWD;
      else this->flydirection = DIRECTION_BACK;
    }
  }
  else if (this->button2down) {
    if (dx == 0 && dy == 0) return;
    this->pitchCamera(((float)-dx / float(winsize[0])) * 0.1f);
    this->yawCamera(((float)-dy / float(winsize[1])) * 0.1f);
  }
  else if (this->button3down) {
    if (dy == 0) return;
    float fy = float(dy) / float(winsize[0]);
    this->relspeedfly = SbAbs(fy);
    this->moveCamera(SbVec3f(0.0f, 0.0f, -dy), FALSE);
  }
} // lockedPulse()

// *************************************************************************

/*!
  Yaw camera with \a rad radians.
*/

void
So@Gui@SuperCanvasP::yawCamera(const float rad)
{
  SoCamera * camera = owner->getCamera();
  SbMatrix yawmat;
  yawmat.setRotate(SbRotation(SbVec3f(1.0f, 0.0f, 0.0f), rad));
  this->camerarot.multLeft(yawmat);
  this->normalizeCamera();
  camera->orientation = SbRotation(this->camerarot);
  this->resetRoll();
} // yawCamera()

// *************************************************************************

/*!
  Roll camera with \a rad radians.
*/

void
So@Gui@SuperCanvasP::rollCamera(const float rad)
{
  SoCamera * camera = owner->getCamera();
  SbMatrix rollmat;
  rollmat.setRotate(SbRotation(SbVec3f(0.0f, 0.0f, 1.0f), rad));
  this->camerarot.multLeft(rollmat);
  this->normalizeCamera();
  camera->orientation = SbRotation(this->camerarot);
} // rollCamera()

// *************************************************************************

/*!
  Pitch camera with \a rad radians.
*/

void
So@Gui@SuperCanvasP::pitchCamera(const float rad)
{
  SoCamera * camera = owner->getCamera();
  SbMatrix pitchmat;
  pitchmat.setRotate(SbRotation(SbVec3f(0.0f, 1.0f, 0.0f), rad));
  this->camerarot.multLeft(pitchmat);
  this->normalizeCamera();
  camera->orientation = SbRotation(this->camerarot);
  this->resetRoll();
} // pitchCamera()

// *************************************************************************

/*!
  Normalize camera. Done to avoid accummulating error.
*/

void
So@Gui@SuperCanvasP::normalizeCamera(void)
{
  SbVec3f x, y, z;
  x[0] = this->camerarot[0][0];
  x[1] = this->camerarot[0][1];
  x[2] = this->camerarot[0][2];

  y[0] = this->camerarot[1][0];
  y[1] = this->camerarot[1][1];
  y[2] = this->camerarot[1][2];

  x.normalize();
  y.normalize();
  z = x.cross(y);
  z.normalize();

  this->camerarot[0][0] = x[0];
  this->camerarot[0][1] = x[1];
  this->camerarot[0][2] = x[2];

  this->camerarot[1][0] = y[0];
  this->camerarot[1][1] = y[1];
  this->camerarot[1][2] = y[2];

  this->camerarot[2][0] = z[0];
  this->camerarot[2][1] = z[1];
  this->camerarot[2][2] = z[2];

  this->camerarot[3][0] = 0.0f;
  this->camerarot[3][1] = 0.0f;
  this->camerarot[3][2] = 0.0f;
  this->camerarot[3][3] = 1.0f;
  this->camerarot[0][3] = 0.0f;
  this->camerarot[1][3] = 0.0f;
  this->camerarot[2][3] = 0.0f;
} // normalizeCamera()

// *************************************************************************

/*!
  Resets the roll. Useful if you want the "up" vector of the camera to
  be pointing as much up as possible.
*/

void
So@Gui@SuperCanvasP::resetRoll(void)
{
  if (!this->doresetroll) return;
  SbVec3f newy = this->viewupaxis;
  if (newy == SbVec3f(0.0f, 0.0f, 0.0f)) return;
  SbVec3f Z;
  Z[0] = this->camerarot[2][0];
  Z[1] = this->camerarot[2][1];
  Z[2] = this->camerarot[2][2];

  if (fabs(Z.dot(newy)) > 0.99f) {
    // just give up
    return;
  }
  SbVec3f newx = newy.cross(Z);
  newy = Z.cross(newx);

  newx.normalize();
  newy.normalize();

  this->camerarot[0][0] = newx[0];
  this->camerarot[0][1] = newx[1];
  this->camerarot[0][2] = newx[2];

  this->camerarot[1][0] = newy[0];
  this->camerarot[1][1] = newy[1];
  this->camerarot[1][2] = newy[2];
} // resetRoll()

// *************************************************************************

/*!
  Convenience metod that moves the current camera. This must be
  used if you intend to record the speed of the camera.
*/

void
So@Gui@SuperCanvasP::moveCamera(const SbVec3f &vec, const SbBool dorotate)
{
  if (vec.sqrLength() == 0.0f) return;
  SoCamera * camera = (SoCamera*) owner->getCamera();
 
  SbVec3f dst = vec;
  if (dorotate) {
    this->camerarot.multDirMatrix(vec, dst);
  }
  if (this->viewmode == So@Gui@SuperCanvas::FLYMODE_LOCKED && dorotate) 
    dst[2] = 0.0f;

  float speed = this->flymode == So@Gui@SuperCanvas::FLYMODE_GLIDE ?
    this->glidespeed*this->relspeedglide :
    this->flyspeed*this->relspeedfly;

  SbTime difftime = SbTime::getTimeOfDay() - this->prevRedrawTime;
  float diffval = (float) difftime.getValue();

  float dist = SbMin(diffval, 0.1f) * speed;

  if (dist == 0.0f) return;

  camera->position = camera->position.getValue() + dst*dist;
} // moveCamera()

// *************************************************************************

/*!
  FIXME: Docs larsivi 20020604
*/

void
So@Gui@SuperCanvasP::flyCameraSetup()
{
  if(this->flying){
    if (this->currcam) {
      this->camerapossensor->detach();
      this->cameraorientsensor->detach();
    }
    this->currcam = owner->getCamera();
    
    this->camerapossensor->attach(&this->currcam->position);
    
    this->cameraorientsensor->attach(&this->currcam->orientation);
    this->camerarot.setRotate(this->currcam->orientation.getValue());
    
    So@Gui@SuperCanvasP::camera_pos_cb((void*)this, 
                                    this->camerapossensor);
    So@Gui@SuperCanvasP::camera_orient_cb((void*)this, 
                                       this->cameraorientsensor);
  }
  else{
    if (this->currcam) {
      this->camerapossensor->detach();
      this->cameraorientsensor->detach();
      this->currcam = NULL;
    }
  }
} // flyCameraSetup()

// ************************************************************************

/*!
  FIXME: Docs larsivi 20020604
*/

void
So@Gui@SuperCanvasP::findCameras()
{
  this->searchaction = new SoSearchAction;
  this->searchaction->reset(); 
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setInterest(SoSearchAction::ALL);
  this->searchaction->setType(SoCamera::getClassTypeId());
  this->searchaction->apply(this->currentroot);
  SoPathList camerapaths = this->searchaction->getPaths();
  if(this->cameras.getLength()) this->cameras.truncate(0);
  
  SoCamera * cam = owner->getCamera();
  this->frontcamera = TRUE;
  for(int i = 0; i < camerapaths.getLength(); i++){
    this->cameras.append((SoCamera *)camerapaths[i]->getTail());
    if(cam->getNodeId() == cameras[i]->getNodeId()) this->frontcamera = FALSE;
  } 

  delete this->searchaction;
  this->searchaction = NULL;
} // findCameras()

// *************************************************************************

/*!
  FIXME: Docs larsivi 20020604
*/

void
So@Gui@SuperCanvasP::findLights()
{
  this->searchaction = new SoSearchAction;
  this->searchaction->reset(); 
  this->searchaction->setSearchingAll(TRUE);
  this->searchaction->setInterest(SoSearchAction::ALL);
  this->searchaction->setType(SoLight::getClassTypeId());
  this->searchaction->apply(this->currentroot);
  SoPathList lightpaths = this->searchaction->getPaths();
  if(this->lights.getLength()) this->lights.truncate(0);
 
  for(int i = 0; i < lightpaths.getLength(); i++){
    SoLight * light = (SoLight *)lightpaths[i]->getTail();
    if(this->lights.find(light) == -1){
      light->on = FALSE;
      this->lights.append(light);
    }
  }

  delete this->searchaction;
  this->searchaction = NULL;
} // findLights()
