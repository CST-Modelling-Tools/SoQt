/**************************************************************************\
 *
 *  This file is part of the Coin GUI toolkit libraries.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public License
 *  version 2.1 as published by the Free Software Foundation.  See the
 *  file LICENSE.LGPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you want to use this library with software that is incompatible
 *  licensewise with the LGPL, and / or you would like to take
 *  advantage of the additional benefits with regard to our support
 *  services, please contact Systems in Motion about acquiring a Coin
 *  Professional Edition License.  See <URL:http://www.coin3d.org> for
 *  more information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

// @configure_input@

// *************************************************************************

/*!
  \class So@Gui@SuperCanvas So@Gui@SuperCanvas.h
  \brief The So@Gui@SuperCanvas class adds more functionality to So@Gui@Viewer

*/

// NOTE: The So@Gui@SuperCanvas.cpp sourcecode file is completely
// autogenerated from "templatized" source code.

// *************************************************************************

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H
#include "So@Gui@SuperCanvas.h"
#include "So@Gui@SuperCanvasP.h"

#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/nodes/SoShapeHints.h>
#include <Inventor/nodes/SoNormal.h>
#include <Inventor/nodes/SoNormalBinding.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/nodes/SoCamera.h>
#include <Inventor/nodes/SoLight.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/events/SoLocation2Event.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/events/SoMotion3Event.h>
#include <Inventor/projectors/SbSphereSheetProjector.h>

#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/So@Gui@Cursor.h>

// *************************************************************************

#define PRIVATE(o) (o->pimpl)

// *************************************************************************

/*!
  Constructor.
  FIXME: More doc. larsivi 20020603
*/

So@Gui@SuperCanvas::So@Gui@SuperCanvas(@WIDGET@ parent,
                    const char * name,
                    SbBool embed,
                    Type type,
                    SbBool build)
  : So@Gui@Viewer(parent, name, embed, type, FALSE)
{
  PRIVATE(this) = new SoQtSuperCanvasP(this);
  if (build) {
    this->setClassName("So@Gui@SuperCanvas");
    @WIDGET@ widget = this->buildWidget(this->getParentWidget());
    this->setBaseWidget(widget);
  }
} // So@Gui@SuperCanvas()

// *************************************************************************

/*!
  Destructor.
*/

So@Gui@SuperCanvas::~So@Gui@SuperCanvas(void)
{
  delete PRIVATE(this);
}; // ~So@Gui@SuperCanvas()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setDrawStyle(DrawStyle drawstyle, SbBool enable)
{
  switch(drawstyle){
  case So@Gui@SuperCanvas::FILLED:
     PRIVATE(this)->filled = enable;
     if(!enable)
       PRIVATE(this)->drawstyleroot->whichChild = SO_SWITCH_ALL;
     else
       PRIVATE(this)->drawstyleroot->whichChild = PRIVATE(this)->complexityindex;
     break;
  case So@Gui@SuperCanvas::BOUNDINGBOXES:
    if(!enable == PRIVATE(this)->boundingboxesenabled)
      enable ? PRIVATE(this)->drawstyles++ : 
               PRIVATE(this)->drawstyles--;
    PRIVATE(this)->boundingboxesenabled = enable;
    break;
  case So@Gui@SuperCanvas::WIREFRAME:
    if(!enable == PRIVATE(this)->wireframeenabled)
       enable ? PRIVATE(this)->drawstyles++ : 
                PRIVATE(this)->drawstyles--;
    PRIVATE(this)->wireframeenabled = enable;
    break;
  case So@Gui@SuperCanvas::VERTICES:
    if(!enable == PRIVATE(this)->verticesenabled)
       enable ? PRIVATE(this)->drawstyles++ : 
                PRIVATE(this)->drawstyles--;
    PRIVATE(this)->verticesenabled = enable;
    break;
  case So@Gui@SuperCanvas::TEXTURES:
    PRIVATE(this)->texturesenabled = enable;
    if(!enable){
      PRIVATE(this)->complexity->textureQuality = 0.0;
      PRIVATE(this)->drawstyleroot->whichChild = PRIVATE(this)->complexityindex;
    }
    else{
      PRIVATE(this)->complexity->textureQuality = PRIVATE(this)->texturequality;
    }
    break;
  case So@Gui@SuperCanvas::HIDDEN_PARTS:
    if(!enable == PRIVATE(this)->hiddenpartsenabled)
      enable ? PRIVATE(this)->drawstyles++ : 
               PRIVATE(this)->drawstyles--;
    PRIVATE(this)->hiddenpartsenabled = enable;
    break;
  }
  this->scheduleRedraw();

} // setDrawStyle()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isDrawStyle(DrawStyle drawstyle) const
{
  if(drawstyle <= 0) return FALSE;

  switch(drawstyle){
  case FILLED:
    return PRIVATE(this)->filled;
  case BOUNDINGBOXES:
    return PRIVATE(this)->boundingboxesenabled;
  case WIREFRAME:
    return PRIVATE(this)->wireframeenabled;
  case VERTICES:
    return PRIVATE(this)->verticesenabled;
  case TEXTURES:
    return PRIVATE(this)->texturesenabled;
  case HIDDEN_PARTS:
    return PRIVATE(this)->hiddenpartsenabled;
  default:
    return FALSE;
  }

} // isDrawStyle()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setInformation(SbBool enable)
{
  PRIVATE(this)->informationenabled = enable;
  this->scheduleRedraw();
} // setInformation()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isInformation(void) const
{
  return PRIVATE(this)->informationenabled;
} // isInformation()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::enableMouse(SbBool enable)
{
  PRIVATE(this)->mouseenabled = enable;
} // enableMouse()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isMouseEnabled(void) const
{
  return PRIVATE(this)->mouseenabled;
} // isMouseEnabled()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setDistance(SbBool enable)
{
  PRIVATE(this)->distanceenabled = enable;
  this->scheduleRedraw();
} // setDistance()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isDistance(void) const
{
  return PRIVATE(this)->distanceenabled;
} // isDistance()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setFlatshading(SbBool enable)
{
  PRIVATE(this)->flatshadingenabled = enable;

  if(enable){
    
    if(PRIVATE(this)->shapehints == NULL) 
      PRIVATE(this)->shapehints = new SoShapeHints;
    PRIVATE(this)->shapehints->creaseAngle = 0.0;
    PRIVATE(this)->shapehints->setOverride(TRUE);
    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->insertChild(PRIVATE(this)->shapehints, 0);
    
    PRIVATE(this)->emptynormal = new SoNormal;
    PRIVATE(this)->emptynormal->setOverride(TRUE);
    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->insertChild(PRIVATE(this)->emptynormal, 0);
    
    PRIVATE(this)->emptynormalbinding = new SoNormalBinding;
    PRIVATE(this)->emptynormalbinding->setOverride(TRUE);
    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->insertChild(PRIVATE(this)->emptynormalbinding, 0);
  }
  else{

    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->removeChild(PRIVATE(this)->shapehints);
    PRIVATE(this)->shapehints = NULL;
    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->removeChild(PRIVATE(this)->emptynormal);
    PRIVATE(this)->emptynormal = NULL;
    ((SoSeparator *)this->getSceneManager()->getSceneGraph())
      ->removeChild(PRIVATE(this)->emptynormalbinding);
    PRIVATE(this)->emptynormalbinding = NULL;
  }

} // setFlatshading()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isFlatshading(void) const
{
  return PRIVATE(this)->flatshadingenabled;
} // isFlatshading()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setAnimationEnabled(const SbBool enable)
{
  PRIVATE(this)->spinanimatingallowed = enable;
}  // setAnimationEnabled()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isAnimationEnabled(void) const
{
  return PRIVATE(this)->spinanimatingallowed;
} // isAnimationEnabled()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setAnimating(SbBool enable)
{
  PRIVATE(this)->spinanimating = enable;
} // setAnimating()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isAnimating(void) const
{
  return PRIVATE(this)->spinanimating;
} // isAnimating()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::stopAnimating(void)
{
  if (PRIVATE(this)->spinanimating) {
    PRIVATE(this)->spinanimating = FALSE;
    this->interactiveCountDec();
  }
} // stopAnimating()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setLineWidth(int value)
{
  PRIVATE(this)->drawstyle->lineWidth.setValue(value);
} // setLineWidth()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

int
So@Gui@SuperCanvas::getLineWidth(void) const
{
  return PRIVATE(this)->drawstyle->lineWidth.getValue();
} // getLineWidth()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setPointSize(int value)
{
  PRIVATE(this)->drawstyle->pointSize.setValue(value);
} // setPointSize()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

int
So@Gui@SuperCanvas::getPointSize(void) const
{
  return PRIVATE(this)->drawstyle->pointSize.getValue();
} // getPointSize()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setPointColor(const SbColor & color)
{
  PRIVATE(this)->pointcolor = color;
} // setPointColor()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbColor &
So@Gui@SuperCanvas::getPointColor(void) const
{
  return PRIVATE(this)->pointcolor;
} // getPointColor()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setLineColor(const SbColor & color)
{
  PRIVATE(this)->linecolor = color;
} // setLineColor()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbColor &
So@Gui@SuperCanvas::getLineColor(void) const
{
  return PRIVATE(this)->linecolor;
} // getLineColor()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setRenderType(SoComplexity::Type type)
{
  PRIVATE(this)->complexity->type = type;
}  // setRenderType()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbName &
So@Gui@SuperCanvas::getRenderType(void) const
{
  SbName * enumname = new SbName("");
  PRIVATE(this)->complexity->type.getEnum(
    PRIVATE(this)->complexity->type.getValue(), *enumname);
  return *enumname;
}  // getRenderType()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setRenderQuality(float value)
{
  PRIVATE(this)->complexity->value.setValue(value);
} // setRenderQuality()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/


float
So@Gui@SuperCanvas::getRenderQuality(void) const
{
  return PRIVATE(this)->complexity->value.getValue();
} // getRenderQuality()

// ************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setTextureQuality(float value)
{
  PRIVATE(this)->complexity->textureQuality.setValue(value);
} // setTextureQuality()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

float
So@Gui@SuperCanvas::getTextureQuality(void) const
{
  return PRIVATE(this)->complexity->textureQuality.getValue();
} // getTextureQuality()

// *************************************************************************

/*!
  Set the camera we want to view the scene with.

  The index passed in as an argument points to the internal camera list.
  This method is a convenience method so the application programmer don't
  need to search for cameras in the scenegraph.

  \sa getNumCameras()
*/

void
So@Gui@SuperCanvas::setCamera(int index)
{
  if(index < 0 || index >= PRIVATE(this)->cameras.getLength()) return;
  
  SoCamera * cam = PRIVATE(this)->cameras[PRIVATE(this)->frontcamera ? 
                                         index + 1 : index];
  So@Gui@Viewer::setCamera(cam);
  
  if(!PRIVATE(this)->currentroot || !cam) return;
  int idx = -1;
  SoGroup * node = PRIVATE(this)->getParentOfNode(
                   PRIVATE(this)->currentroot, cam, idx);
  if(!node){
    PRIVATE(this)->cameraswitch = NULL;
    return;
  }
  if(node->getTypeId() == SoSwitch::getClassTypeId()){
    PRIVATE(this)->cameraswitch = (SoSwitch *)node;
    PRIVATE(this)->cameraswitch->whichChild = idx;
  }
  if(PRIVATE(this)->flying) PRIVATE(this)->flyCameraSetup();
  PRIVATE(this)->setBBoxCameraType();
} // setCamera()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

int
So@Gui@SuperCanvas::getNumCameras(void) const
{
  return PRIVATE(this)->cameras.getLength();
} // getNumCameras()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020604
*/

void
So@Gui@SuperCanvas::setLight(int index, SbBool enable)
{
  if(index < 0 || index >= PRIVATE(this)->lights.getLength()) return;

  ((SoLight*)PRIVATE(this)->lights[index])->on.setValue(enable);

} // setLight()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

int
So@Gui@SuperCanvas::getNumLights(void) const
{
  return PRIVATE(this)->lights.getLength();
} // getNumLights()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SoLight *
So@Gui@SuperCanvas::getLight(int index)
{
  if(index < 0 || index >= PRIVATE(this)->lights.getLength()) return NULL;

  return (SoLight*)PRIVATE(this)->lights[index];
} // getLight()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setViewMode(ViewMode mode)
{
  PRIVATE(this)->viewmode = mode;
  if(mode == INTERACT){ 
    this->setViewing(FALSE);
    PRIVATE(this)->flying = FALSE;
  }
  else{ 
    this->setViewing(TRUE);
    if(mode != EXAMINE)
      PRIVATE(this)->flying = TRUE;
    else
      PRIVATE(this)->flying = FALSE;
  }
  
} // setViewMode()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

So@Gui@SuperCanvas::ViewMode
So@Gui@SuperCanvas::getViewMode(void) const
{
  return PRIVATE(this)->viewmode;
} // getViewMode()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::setWhileMoving(WhileMoving how)
{
  PRIVATE(this)->howtomove = how;
  PRIVATE(this)->notmovingfull = how != FULL_MODEL_WM ? TRUE : FALSE;
} // setWhileMoving()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isWhileMoving(WhileMoving how) const
{
  return how & PRIVATE(this)->howtomove ? TRUE : FALSE;
} // isWhileMoving()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::isViewMode(ViewMode mode) const
{
  return mode & PRIVATE(this)->viewmode ? TRUE : FALSE;
} // isViewMode()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

@WIDGET@
So@Gui@SuperCanvas::getRenderAreaWidget(void) const
{
  return PRIVATE(this)->canvas;
} // getRenderAreaWidget()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

const char *
So@Gui@SuperCanvas::getDefaultWidgetName(void) const
{
  static const char defaultWidgetName[] = "So@Gui@SuperCanvas";
  return defaultWidgetName;
} // getDefaultWidgetName()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

const char *
So@Gui@SuperCanvas::getDefaultTitle(void) const
{
  static const char defaultTitle[] = "SuperCanvas";
  return defaultTitle;
} // getDefaultTitle()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

const char *
So@Gui@SuperCanvas::getDefaultIconTitle(void) const
{
  static const char defaultIconTitle[] = "SuperCanvas";
  return defaultIconTitle;
} // getDefaultIconTitle()

// *************************************************************************

/*!
  FIXME: More doc. larsivi 20020603
*/

void
So@Gui@SuperCanvas::actualRedraw(void)
{
  if(PRIVATE(this)->drawstyledirty) 
    PRIVATE(this)->drawstyleRedraw(FALSE);
  if(PRIVATE(this)->movingdirty)
    PRIVATE(this)->movingRedraw(FALSE);
  
  if(this->getInteractiveCount() &&  PRIVATE(this)->notmovingfull){
    PRIVATE(this)->movingRedraw(TRUE);
  }

  So@Gui@Viewer::actualRedraw();
  
  if(PRIVATE(this)->howtomove != So@Gui@SuperCanvas::ONE_BOUNDINGBOX_WM && 
     PRIVATE(this)->drawstyles)
    PRIVATE(this)->drawstyleRedraw(TRUE);

  SbTime thisRedrawTime = SbTime::getTimeOfDay();
  double secs =
    thisRedrawTime.getValue() - PRIVATE(this)->prevRedrawTime.getValue();

  PRIVATE(this)->prevRedrawTime = thisRedrawTime;

  if (this->isAnimating()) {
    SbRotation deltaRotation = PRIVATE(this)->spinRotation;
    deltaRotation.scaleAngle(secs * 5.0);
    PRIVATE(this)->reorientCamera(deltaRotation);
  }

  // the primitivescount
  if(this->isInformation())
    PRIVATE(this)->drawInformation();
} // actualRedraw()

// *************************************************************************

#define MOUSEBUTTON_EVENT_TYPE  (SoMouseButtonEvent::getClassTypeId())
#define LOCATION2_EVENT_TYPE    (SoLocation2Event::getClassTypeId())
#define MOTION3_EVENT_TYPE      (SoMotion3Event::getClassTypeId())
#define KEYBOARD_EVENT_TYPE     (SoKeyboardEvent::getClassTypeId())

/*!
  FIXME: More doc. larsivi 20020603
*/

SbBool
So@Gui@SuperCanvas::processSoEvent(const SoEvent * const ev)
{
  // Events while in INTERACT mode are sent to So@Gui@Viewer
  if (!this->isViewing()) { return inherited::processSoEvent(ev); }
    
  if(!PRIVATE(this)->mouseenabled) return TRUE;

  // Events during seeks are ignored, except those which influence the
  // seek mode itself -- these are handled further up the inheritance
  // hierarchy.
  if (this->isSeekMode()) { return inherited::processSoEvent(ev); }

  if (PRIVATE(this)->flying && 
      (ev->getTypeId() == LOCATION2_EVENT_TYPE ||
       ev->getTypeId() == MOUSEBUTTON_EVENT_TYPE))
    return PRIVATE(this)->processFlyEvent(ev);

  PRIVATE(this)->canvasvec = this->getGLSize();
  const SoType type(ev->getTypeId());
  const SbVec2f prevnormalized = PRIVATE(this)->lastmouseposition;
  const SbVec2s pos(ev->getPosition());
  const SbVec2f posn((float) pos[0] / (float) So@Gui@Max((int)(PRIVATE(this)->canvasvec[0]-1), 1),
                     (float) pos[1] / (float) So@Gui@Max((int)(PRIVATE(this)->canvasvec[1]-1), 1));

  PRIVATE(this)->lastmouseposition = posn;

  // Set to TRUE if any event processing happened. Note that it is not
  // necessary to restrict ourselves to only do one "action" for an
  // event, we only need this flag to see if any processing happened
  // at all.
  SbBool processed = FALSE;

  // Mismatches in state of the Ctrl key happens if the user presses
  // or releases it outside the viewer window.
  if (PRIVATE(this)->controldown != ev->wasCtrlDown()) {
    PRIVATE(this)->controldown = ev->wasCtrlDown();
    processed = TRUE;
  }

  // Mouse Button / Spaceball Button handling

  if (type.isDerivedFrom(MOUSEBUTTON_EVENT_TYPE)) {
    const SoMouseButtonEvent * const event = (const SoMouseButtonEvent *) ev;
    const int button = event->getButton();
    const SbBool press = event->getState() == SoButtonEvent::DOWN ? TRUE : FALSE;


    switch (button) {
    case SoMouseButtonEvent::BUTTON1:
      PRIVATE(this)->button1down = press;
      break;
    case SoMouseButtonEvent::BUTTON2:
      PRIVATE(this)->button2down = press;
      break;
    case SoMouseButtonEvent::BUTTON3:
      PRIVATE(this)->button3down = press;
      break;
    default:
      break;
    } // switch (button)

    if (press) {
      switch (button) {
      case SoMouseButtonEvent::BUTTON1:
        if (! this->isSeekMode()) {
          if (this->isAnimating()) this->stopAnimating();
          this->interactiveCountInc();
          PRIVATE(this)->clearLog();
          processed = TRUE;
        }
        break;

      case SoMouseButtonEvent::BUTTON3:
        {
          if (this->isAnimating()) this->stopAnimating();
          this->interactiveCountInc();
          SoCamera * const camera = this->getCamera();
          if (camera == NULL) { // can happen for empty scenegraph
            PRIVATE(this)->panningplane = SbPlane(SbVec3f(0, 0, 1), 0);
          }
          else {
            SbViewVolume volume = camera->getViewVolume(this->getGLAspectRatio());
            PRIVATE(this)->panningplane = volume.getPlane(camera->focalDistance.getValue());
          }
          processed = TRUE;
        }
        break;

#ifdef HAVE_SOMOUSEBUTTONEVENT_BUTTON5
      case SoMouseButtonEvent::BUTTON4:
        PRIVATE(this)->zoom(-0.1f);
        processed = TRUE;
        break;

      case SoMouseButtonEvent::BUTTON5:
        PRIVATE(this)->zoom(0.1f);
        processed = TRUE;
        break;
#endif // HAVE_SOMOUSEBUTTONEVENT_BUTTON5

      default:
        break;
      } // switch (button)

    } else { // ! press
      switch (button) {
      case SoMouseButtonEvent::BUTTON1:
        {
          this->stopAnimating();
          if (! this->isSeekMode()) {
            if (! this->isAnimationEnabled() || PRIVATE(this)->log.historysize < 3) {
              // FIXME: attention: here lies dragons! This will f*ck
              // up the interactioncounter if a mouse release "just
              // happens", as can be the case (dependent on the native
              // UI toolkit). At least Win32 can give us a release
              // event with no press event in advance. 20010709 mortene.
              this->interactiveCountDec();
            }
            else {
              const SbVec2s glsize(this->getGLSize());
              SbVec3f from = PRIVATE(this)->spinprojector->
                project(SbVec2f(float(PRIVATE(this)->log.position[2][0]) / 
                                float(SoQtMax(glsize[0]-1, 1)),
                                float(PRIVATE(this)->log.position[2][1]) / 
                                float(SoQtMax(glsize[1]-1, 1))));
              SbVec3f to = PRIVATE(this)->spinprojector->project(posn);
              SbRotation rot = PRIVATE(this)->spinprojector->getRotation(from, to);

              SbTime stoptime = (event->getTime() - PRIVATE(this)->log.time[0]);
              if (stoptime.getValue() > 0.1) {
                this->interactiveCountDec();
              }
              else {
                SbTime delta = (PRIVATE(this)->log.time[0] - PRIVATE(this)->log.time[2]);
                float deltatime = (float) delta.getValue();

                rot.invert();
                rot.scaleAngle(0.2f / deltatime);
                
                SbVec3f axis;
                float radians;
                rot.getValue(axis, radians);
                if (radians < 0.01f || deltatime > 0.3f) {
                  this->interactiveCountDec();
                }
                else {
                  PRIVATE(this)->spinRotation = rot;
                  PRIVATE(this)->spinanimating = TRUE;
                  this->scheduleRedraw();
                }
              }
            }
          }
        }
        processed = TRUE;
        break;

      case SoMouseButtonEvent::BUTTON3:
        this->interactiveCountDec();
        processed = TRUE;
        break;

#ifdef HAVE_SOMOUSEBUTTONEVENT_BUTTON5
      case SoMouseButtonEvent::BUTTON4:
        processed = TRUE; // don't pass on
        break;

      case SoMouseButtonEvent::BUTTON5:
        processed = TRUE; // don't pass on
        break;
#endif // HAVE_SOMOUSEBUTTONEVENT_BUTTON5

      default:
        break;
      } // switch (button)
    }
  }

  // Mouse Movement handling
  if (type.isDerivedFrom(LOCATION2_EVENT_TYPE)) {
    const SoLocation2Event * const event = (const SoLocation2Event *) ev;

    if (PRIVATE(this)->button1down || PRIVATE(this)->button3down) processed = TRUE;

    if ((PRIVATE(this)->button1down && PRIVATE(this)->button3down) ||
         (PRIVATE(this)->button3down && PRIVATE(this)->controldown)) {
      PRIVATE(this)->zoomByCursor(posn, prevnormalized);
    }
    else if ((PRIVATE(this)->button1down && PRIVATE(this)->controldown) || PRIVATE(this)->button3down) {
      PRIVATE(this)->pan(posn, prevnormalized);
    }
    else if (PRIVATE(this)->button1down) {
      PRIVATE(this)->addToLog(event->getPosition(), event->getTime());
      PRIVATE(this)->spin(posn);
    }
  }

  // Keyboard handling
  if (type.isDerivedFrom(KEYBOARD_EVENT_TYPE)) {
    const SoKeyboardEvent * const event = (const SoKeyboardEvent *) ev;
    const SbBool press = event->getState() == SoButtonEvent::DOWN ? TRUE : FALSE;
    if (press) {
      if (event->getKey() == SoKeyboardEvent::LEFT_CONTROL
        || event->getKey() == SoKeyboardEvent::RIGHT_CONTROL) {
        PRIVATE(this)->controldown = TRUE;
        processed = TRUE;
      }
    } else {
      if (event->getKey() == SoKeyboardEvent::LEFT_CONTROL
        || event->getKey() == SoKeyboardEvent::RIGHT_CONTROL) {
        PRIVATE(this)->controldown = FALSE;
        processed = TRUE;
      }
    }
  }

  // Spaceball & Joystick handling
  if (type.isDerivedFrom(MOTION3_EVENT_TYPE)) {
    SoMotion3Event * const event = (SoMotion3Event *) ev;
    SoCamera * const camera = this->getCamera();
    if (camera) {
      if (PRIVATE(this)->motion3oncamera) {
        camera->position =
          camera->position.getValue() + event->getTranslation();
        camera->orientation =
          camera->orientation.getValue() * event->getRotation();
        processed = TRUE;
      } else {
        // FIXME: move/rotate model
#if SO@GUI@_DEBUG
        SoDebugError::postInfo("So@Gui@SuperCanvas::processSoEvent",
                               "SoMotion3Event for model movement is not implemented yet");
#endif // SO@GUI@_DEBUG
        processed = TRUE;
      }
    }
  }

  if (processed) {
    enum { STATE_LMB = 0x01, STATE_MMB = 0x02, STATE_CTRL = 0x04 };
    unsigned short stateflags =
      (PRIVATE(this)->button1down ? STATE_LMB : 0) +
      (PRIVATE(this)->button3down ? STATE_MMB : 0) +
      (PRIVATE(this)->controldown ? STATE_CTRL : 0);

    So@Gui@SuperCanvasP::HelpMode mode;

    switch (stateflags) {
    case 0:
      mode = So@Gui@SuperCanvasP::INTERACT;
      break;

    case STATE_LMB:
      mode = So@Gui@SuperCanvasP::DRAGGING;
      break;

    case STATE_MMB:
    case (STATE_LMB | STATE_CTRL):
      mode = So@Gui@SuperCanvasP::PANNING;
      break;

    case STATE_CTRL:
      mode = So@Gui@SuperCanvasP::WAITING_FOR_PAN;
      break;

    case (STATE_MMB | STATE_CTRL):
    case (STATE_LMB | STATE_MMB):
    case (STATE_LMB | STATE_MMB | STATE_CTRL):
      mode = So@Gui@SuperCanvasP::ZOOMING;
      break;

    default:
      assert(FALSE && "unhandled input state");
      break;
    }

    PRIVATE(this)->setMode(mode);
  }

  // If not handled in this class, pass on upwards in the inheritance
  // hierarchy.
  return processed || inherited::processSoEvent(ev);
} // processSoEvent()

// *************************************************************************

/*!
  FIXME: add docs larsivi 20020606
*/

void
So@Gui@SuperCanvas::setSceneGraph(SoNode * scene)
{
  if(PRIVATE(this)->graphswitch == NULL){
    PRIVATE(this)->graphswitch = new SoSwitch;
    PRIVATE(this)->graphswitch->addChild(scene);
    PRIVATE(this)->graphswitch->whichChild = 0;
  }
  else
    PRIVATE(this)->graphswitch->replaceChild(0, scene);

  PRIVATE(this)->currentroot = scene;
  So@Gui@Viewer::setSceneGraph(PRIVATE(this)->graphswitch);

  // Fetching variables necessary for the viewers functionality
  if(PRIVATE(this)->supersg == NULL)
    PRIVATE(this)->setupNodes();

  PRIVATE(this)->findCameras();
  if(!PRIVATE(this)->frontcamera){
    PRIVATE(this)->bboxroot->whichChild = SO_SWITCH_ALL;
    PRIVATE(this)->setBBoxCameraType();
  }
  else
    PRIVATE(this)->bboxroot->whichChild = 1;
  PRIVATE(this)->findLights();
  PRIVATE(this)->resetCountAction();
  PRIVATE(this)->resetBBox();
  this->saveHomePosition();
} // setSceneGraph()

// *************************************************************************

/*!
  FIXME: add docs larsivi 20020606
*/

SoNode *
So@Gui@SuperCanvas::loadSceneGraphFromFile(const char * filename)
{
  SoInput in;
  SoNode * newroot;

  if (in.openFile(filename)) {
    newroot = SoDB::readAll(&in);
    if (newroot){
      return newroot;
    }
    else{
      SoDebugError::postInfo("So@Gui@SuperCanvas::loadSceneGraphFromFile", 
                             "[no root loaded]");
      return NULL;
    }
  }
  else{
    SoDebugError::postInfo("So@Gui@SuperCanvas::loadSceneGraphFromFile", 
                           "[opening file failed]");
    return NULL;
  }

} // loadSceneGraphFromFile()
